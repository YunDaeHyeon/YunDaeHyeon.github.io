---
layout: post
title: "[Java, 자료구조] Singly LinkedList(단일 연결리스트) 구현하기 (1/2) - 인터페이스"
data:   2022-02-20 16:54:00+0900
categories: jekyll update
tags: [java, data structure]
---
해당 포스팅은 자료구조 중 하나인 **List**에 대해 이해하기 위해 스터디 목적으로 직접 List을 구현해보는 포스팅이다. Java에서 지원하는 List 클래스에 대한 사용법이 아니다. 실습을 진행할 때 사용된 코드는 모두 [Stranger's Lab](https://st-lab.tistory.com/174?category=856997)님의 게시글과 설명을 참고로 하여 구현하였다.

# List란?
리스트(List)는 생각보다 단순하며 널리 쓰인다. 데이터의 목록을 다루는 구조가 단순한 기초적인 자료구조이다. 리스트(List)는 `Stack`, `Queue`, `Tree`, `Graph`와 같은 다양한 자료구조 구현에 활용되는 기초적인 구조이다. 리스트(List)는 **데이터를 순차적으로 저장하며 선형 구조를 가진다.**  
이때, **선형구조란 데이터가 순차적으로 저장되기 때문에 끊어지지 않으며 한 줄로 계속 이어지기에 마치 선과 같은 형태를 가진다 하여 `선형구조`라 부른다.** 크게 리스트(List)는 구형방식에 따라서 `ArrayList`와 `LinkedList`로 구분되어 진다. 자료구조의 이해를 위하여 해당 포스팅에서는 `LinkedList`를 직관적으로 이해하기 위해 직접 구현을 할 것이며 이에 필요한 인터페이스를 작성할 것이다. 자바에서는 하나의 리스트가 아닌 `ArrayList`와 `LinkedList`를 지원하는 이유는 List의 사용 방법에 따라 효율성이 나뉘기 때문이다.  
**만약, 어떠한 로직에서 데이터를 번번히 조회한다면 `ArrayList`가 속도와 효율성이 매우 좋을 것이며 데이터의 추가/삭제가 번번하게 발생한다면 `LinkedList`가 훨씬 효과적이다.**

# List의 특징
- 자료를 순서대로 한 줄로 저장하는 자료구조이다. (여러 자료가 일직선으로 연결된 선형구조를 가진다.)  
- 제일 처음 요소를 `Head`라 부른다.  
- 제일 마지막 요소를 `Tail`라 부른다.  
- 중복된 데이터를 허용한다.  
- 빈 공간을 허용하지 않는다.  

# 배열과 리스트(List)의 차이점
리스트(List)는 배열과 달리 **동적할당(Dynamic allocation)**의 형태를 가지고 있다. 이는 크기가 계속 바뀌는 가변적 형태를 가지고 있다는 의미이다.  
배열과 리스트(List)의 차이점은 아래와 같다.

## 공통점
- 동일한 특성의 데이터를 묶는다. (선형구조)  
- 반복문내의 변수를 이용하여 하나의 묶음 데이터에 모두 접근할 수 있다.  

## 배열과 리스트(List)의 차이점 - 배열(Array)
- 처음 선언한 배열의 크기는 변경할 수 없으며 이는 정적할당(Static allocation)의 형태를 가지고 있다.  
- **메모리에 연속적으로 나열되어 할당된다.**  
- **index에 위치한 하나의 데이터(요소, element)를 삭제하더라도 해당 index에는 빈공간이 계속 존재한다.**  
배열은 데이터의 크기가 정해져있을 경우 메모리 관리가 편하다. 메모리에 연속으로 나열되기에 index를 통한 색인(접근)속도가 빠르다.  
하지만, 배열의 크기를 변경할 수 없어 **메모리 낭비**가 심해지며 너무 작으면 **데이터를 전부 담을 수 없어** 효율적이지 못하다. 또한, **빈 공간을 허용하지 않고 데이터 추가/삭제와 같은 기능을 사용하고자 한다면 계속 데이터를 밀거나 당겨야하기에 속도가 느려 데이터의 추가/삭제에는 적합하지 않다.**  
  
## 배열과 리스트(List)의 차이점 - 리스트(List)
- 리스트의 길이는 가변적이며 이는 동적할당(Dynamic allocation)의 형태를 가지고 있다.  
- 데이터들이 연속으로 나열된다. 이는 ***메모리에 연속으로 나열되지 않고*** 각 데이터들은 주소(Reference)로 연결되어 있음을 의미한다. (C언어의 포인터)  
- **데이터(요소, element) 사이에 빈 공간을 허용하지 않는다.**
리스트는 데이터의 개수에 따라 **동적할당**을 수행하기에 메모리 관리가 편해지며 **빈 공간을 허용하지 않기에** 데이터 관리에 편하다. 또한, **메모리가 아닌 데이터끼리 연속으로(데이터의 주소 즉, 포인터) 연결되어 있기에 해당 데이터에 연결된 주소만 바꿔주면 되기 때문에 삽입과 삭제에 용이하다.** (이는 LinkedList에 해당하며 ArrayList가 아니다.)  
하지만, 리스트(List)는 **`객체`**로 데이터를 다루기에 적은 양의 데이터를 다룰 경우 **배열보다 차지하는 메모리가 커진다.** 또 기본적으로 주소(포인터)를 기반으로 구성되어 있으며 **메모리가 아닌 데이터끼리 순차적으로 할당되기에(물리적 주소가 순차적이지 않는다는 것을 의미) 색인(검색) 효율은 배열에 비해 많이 떨어진다.**

# 구현할 List 인터페이스의 메소드
1. add(E e) - return type : boolean - 리스트에 요소를 추가한다.  
2. remove(Object o) - return type : boolean - 지정한 객체와 같은 첫 번째 객체를 삭제한다.  
3. contains(Object o) - return type : boolean - 지정한 객체가 컬렉션에 있는지 판별하며 있다면 true를, 없다면 false를 반환한다.  
4. size() - return type : int - 현재 컬렉션에 있는 요소 개수를 반환한다.(크기가 아니다.)  
5. get(int index) - return type : E - 리스트에 특정 위치에 저장된 요소를 가져온다.  
6. set(int index, E elements) - return type : E - 리스트 특정 위치에 있는 요소를 지정된 요소로 바꾼다.  
7. isEmpty() - return type : boolean - 현재 컬렉션에 요소가 없다면 true를, 요소가 존재한다면 false를 반환한다.  
8. indexOf(Object o) - return type : int - 지정된 객체가 있는 첫 번째 요소의 위치를 반환하며 없다면 -1을 반환한다.  
9. clear() - return type : void - 리스트에 있는 모든 요소(Element)를 제거한다.  

# List 인터페이스 구현
```java
package list;

public interface List<E> {

    // 리스트에 요소를 추가한다.
    // 만약, 리스트가 중복을 허용하지 않을 경우. 리스트에 이미 중복되는 요소가 있다면 true를,
    // 중복되는 요소가 없으면 false를 반환.
    boolean add(E value);  // 메소드 오버로딩

    // 리스트 특정 위치에 요소를 추가. (특정 위치 및 이후의 요소들은 한 칸씩 뒤로 밀린다.)
    void add(int index, E value); // 메소드 오버로딩

    // 리스트 index 위치에 있는 요소 삭제
    E remove(int index); // 메소드 오버로딩

    // 리스트에서 특정 요소를 삭제한다. 동일한 요소가 여러 개일 경우 가장 처음 발견한 요소만 삭제한다.
    // 리스트에 삭제할 요소가 없거나 실패하면 false를, 삭제에 성공하면 true를 반환한다.
    boolean remove(Object value); // 메소드 오버로딩

    // 리스트에 있는 특정 위치의 요소를 가져온다.
    E get(int index);

    // 리스트에서 특정 위치에 있는 요소를 새 요소로 대체한다.
    void set(int index, E value);

    // 리스트에서 특정 요소가 리스트에 있는지 여부를 확인한다.
    // 리스트에 특정 요소가 존재한다면 true를, 존재하지 않을 경우 false를 반환.
    boolean contains(Object value);

    // 리스트에 특정 요소가 몇 번째 위치에 있는지 반환한다.
    // 리스트에서 처음으로 일치하는 위치를 반환한다. 일치하는 요소가 없다면 -1을 반환한다.
    int indexOf(Object value);

    // 리스트에 있는 요소의 개수를 반환한다. (리스트의 크기가 아니다.)
    int size();

    // 리스트에 요소가 비어있는 지 판별한다.
    // 리스트에 요소가 없다면 true를, 요소가 있으면 false를 반환한다.
    boolean isEmpty();

    // 리스트에 있는 요소를 모두 삭제한다.
    public void clear();
}

```
  


---
[참고 및 리소스 출처]  
[Stranger's LAB](https://st-lab.tistory.com/1467)  
[크리스의 개발일기](https://devlogofchris.tistory.com/42)  
